{
    "files.associations": {
        "cmath": "cpp"
    }
}


void controlServo9(void *pvParameters){
    for(;;){
        if(run_servo.statusCurrentServo[SERVO_9] == SERVO_OPENING){
            stop_led(SERVO_9);
            open_led(SERVO_9);
            unsigned long start_time = millis();
            if(!reverse_motor[SERVO_9]){
                run_servo.value_open_pwm_servo[SERVO_9] = map(setup_motor.define_open_angle[SERVO_9], PULSE_MS_SERVO_LOW, PULSE_MS_SERVO_HIGH, PWM_SERVO_LOW, PWM_SERVO_HIGH);
                if(run_servo.value_open_pwm_servo[SERVO_9] < PWM_SERVO_LOW){
                    run_servo.value_open_pwm_servo[SERVO_9] = PWM_SERVO_LOW;
                }
                if(run_servo.value_open_pwm_servo[SERVO_9] > PWM_SERVO_HIGH){
                    run_servo.value_open_pwm_servo[SERVO_9] = PWM_SERVO_HIGH;
                }
                uint8_t time_delay = map(setup_motor.define_speed_servo[SERVO_9], MAX_PERCENT_SPEED_SERVO, MIN_PERCENT_SPEED_SERVO, MIN_DELAY_SPEED_SERVO, MAX_DELAY_SPEED_SERVO);
                ECHOLN(time_delay);
                if(run_servo.value_current_pwm_servo[SERVO_9] == run_servo.value_open_pwm_servo[SERVO_9]){
                    goto BREAK_OPEN_SERVO_9;
                }
                if(setup_motor.define_speed_servo[SERVO_9] == MAX_PERCENT_SPEED_SERVO){
                    xSemaphoreTake( xMutexI2C, portMAX_DELAY );
                    pwmController.setChannelPWM(SERVO_9, run_servo.value_open_pwm_servo[SERVO_9]);
                    xSemaphoreGive( xMutexI2C );
                    goto DONE_OPEN_SERVO_NOT_REVERSE_9;
                }
                if(run_servo.value_current_pwm_servo[SERVO_9] <= run_servo.value_open_pwm_servo[SERVO_9]){
                    for(int i = run_servo.value_current_pwm_servo[SERVO_9]; i <= run_servo.value_open_pwm_servo[SERVO_9]; i=i+5){
                        xSemaphoreTake( xMutexI2C, portMAX_DELAY );
                        pwmController.setChannelPWM(SERVO_9, i);
                        xSemaphoreGive( xMutexI2C );
                        vTaskDelay(time_delay/portTICK_RATE_MS);
                    }
                }else{
                    for(int i = run_servo.value_current_pwm_servo[SERVO_9]; i >= run_servo.value_open_pwm_servo[SERVO_9]; i=i-5){
                        xSemaphoreTake( xMutexI2C, portMAX_DELAY );
                        pwmController.setChannelPWM(SERVO_9, i);
                        xSemaphoreGive( xMutexI2C );
                        vTaskDelay(time_delay/portTICK_RATE_MS);
                    }
                }
            DONE_OPEN_SERVO_NOT_REVERSE_9:
                run_servo.value_current_pwm_servo[SERVO_9] = run_servo.value_open_pwm_servo[SERVO_9];
            }
            else{
                run_servo.value_close_pwm_servo[SERVO_9] = map(setup_motor.define_close_angle[SERVO_9], PULSE_MS_SERVO_LOW, PULSE_MS_SERVO_HIGH, PWM_SERVO_LOW, PWM_SERVO_HIGH);
                if(run_servo.value_close_pwm_servo[SERVO_9] < PWM_SERVO_LOW){
                    run_servo.value_close_pwm_servo[SERVO_9] = PWM_SERVO_LOW;
                }
                if(run_servo.value_close_pwm_servo[SERVO_9] > PWM_SERVO_HIGH){
                    run_servo.value_close_pwm_servo[SERVO_9] = PWM_SERVO_HIGH;
                }
                uint8_t time_delay = map(setup_motor.define_speed_servo[SERVO_9], MAX_PERCENT_SPEED_SERVO, MIN_PERCENT_SPEED_SERVO, MIN_DELAY_SPEED_SERVO, MAX_DELAY_SPEED_SERVO);
                ECHOLN(time_delay);
                if(run_servo.value_current_pwm_servo[SERVO_9] == run_servo.value_close_pwm_servo[SERVO_9]){
                    goto BREAK_OPEN_SERVO_9;
                }
                if(setup_motor.define_speed_servo[SERVO_9] == MAX_PERCENT_SPEED_SERVO){
                    xSemaphoreTake( xMutexI2C, portMAX_DELAY );
                    pwmController.setChannelPWM(SERVO_9, run_servo.value_close_pwm_servo[SERVO_9]);
                    xSemaphoreGive( xMutexI2C );
                    goto DONE_OPEN_SERVO_REVERSE_9;
                }
                if(run_servo.value_current_pwm_servo[SERVO_9] <= run_servo.value_close_pwm_servo[SERVO_9]){
                    for(int i = run_servo.value_current_pwm_servo[SERVO_9]; i <= run_servo.value_close_pwm_servo[SERVO_9]; i=i+5){
                        xSemaphoreTake( xMutexI2C, portMAX_DELAY );
                        pwmController.setChannelPWM(SERVO_9, i);
                        xSemaphoreGive( xMutexI2C );
                        vTaskDelay(time_delay/portTICK_RATE_MS);
                    }
                }else{
                    for(int i = run_servo.value_current_pwm_servo[SERVO_9]; i >= run_servo.value_close_pwm_servo[SERVO_9]; i=i-5){
                        xSemaphoreTake( xMutexI2C, portMAX_DELAY );
                        pwmController.setChannelPWM(SERVO_9, i);
                        xSemaphoreGive( xMutexI2C );
                        vTaskDelay(time_delay/portTICK_RATE_MS);
                    }
                }
            DONE_OPEN_SERVO_REVERSE_9:
                run_servo.value_current_pwm_servo[SERVO_9] = run_servo.value_close_pwm_servo[SERVO_9];
            }
            if(time_run_servo[SERVO_9] > (millis() - start_time)){
                vTaskDelay((time_run_servo[SERVO_9] - (millis() - start_time))/portTICK_RATE_MS);
            }
        BREAK_OPEN_SERVO_9:
            stop_led(SERVO_9);
            run_servo.statusCurrentServo[SERVO_9] = SERVO_STOP;
        }
        else if(run_servo.statusCurrentServo[SERVO_9] == SERVO_CLOSING){
            stop_led(SERVO_9);
            close_led(SERVO_9);
            unsigned long start_time = millis();
            if(reverse_motor[SERVO_9]){
                run_servo.value_open_pwm_servo[SERVO_9] = map(setup_motor.define_open_angle[SERVO_9], PULSE_MS_SERVO_LOW, PULSE_MS_SERVO_HIGH, PWM_SERVO_LOW, PWM_SERVO_HIGH);
                if(run_servo.value_open_pwm_servo[SERVO_9] < PWM_SERVO_LOW){
                    run_servo.value_open_pwm_servo[SERVO_9] = PWM_SERVO_LOW;
                }
                if(run_servo.value_open_pwm_servo[SERVO_9] > PWM_SERVO_HIGH){
                    run_servo.value_open_pwm_servo[SERVO_9] = PWM_SERVO_HIGH;
                }
                uint8_t time_delay = map(setup_motor.define_speed_servo[SERVO_9], MAX_PERCENT_SPEED_SERVO, MIN_PERCENT_SPEED_SERVO, MIN_DELAY_SPEED_SERVO, MAX_DELAY_SPEED_SERVO);
                ECHOLN(time_delay);
                if(run_servo.value_current_pwm_servo[SERVO_9] == run_servo.value_open_pwm_servo[SERVO_9]){
                    goto BREAK_CLOSE_SERVO_9;
                }
                if(setup_motor.define_speed_servo[SERVO_9] == MAX_PERCENT_SPEED_SERVO){
                    xSemaphoreTake( xMutexI2C, portMAX_DELAY );
                    pwmController.setChannelPWM(SERVO_9, run_servo.value_open_pwm_servo[SERVO_9]);
                    xSemaphoreGive( xMutexI2C );
                    goto DONE_CLOSE_SERVO_REVERSE_9;
                }
                if(run_servo.value_current_pwm_servo[SERVO_9] <= run_servo.value_open_pwm_servo[SERVO_9]){
                    for(int i = run_servo.value_current_pwm_servo[SERVO_9]; i <= run_servo.value_open_pwm_servo[SERVO_9]; i=i+5){
                        xSemaphoreTake( xMutexI2C, portMAX_DELAY );
                        pwmController.setChannelPWM(SERVO_9, i);
                        xSemaphoreGive( xMutexI2C );
                        vTaskDelay(time_delay/portTICK_RATE_MS);
                    }
                }else{
                    for(int i = run_servo.value_current_pwm_servo[SERVO_9]; i >= run_servo.value_open_pwm_servo[SERVO_9]; i=i-5){
                        xSemaphoreTake( xMutexI2C, portMAX_DELAY );
                        pwmController.setChannelPWM(SERVO_9, i);
                        xSemaphoreGive( xMutexI2C );
                        vTaskDelay(time_delay/portTICK_RATE_MS);
                    }
                }
            DONE_CLOSE_SERVO_REVERSE_9:
                run_servo.value_current_pwm_servo[SERVO_9] = run_servo.value_open_pwm_servo[SERVO_9];
            }
            else{
                run_servo.value_close_pwm_servo[SERVO_9] = map(setup_motor.define_close_angle[SERVO_9], PULSE_MS_SERVO_LOW, PULSE_MS_SERVO_HIGH, PWM_SERVO_LOW, PWM_SERVO_HIGH);
                if(run_servo.value_close_pwm_servo[SERVO_9] < PWM_SERVO_LOW){
                    run_servo.value_close_pwm_servo[SERVO_9] = PWM_SERVO_LOW;
                }
                if(run_servo.value_close_pwm_servo[SERVO_9] > PWM_SERVO_HIGH){
                    run_servo.value_close_pwm_servo[SERVO_9] = PWM_SERVO_HIGH;
                }
                uint8_t time_delay = map(setup_motor.define_speed_servo[SERVO_9], MAX_PERCENT_SPEED_SERVO, MIN_PERCENT_SPEED_SERVO, MIN_DELAY_SPEED_SERVO, MAX_DELAY_SPEED_SERVO);
                ECHOLN(time_delay);
                if(run_servo.value_current_pwm_servo[SERVO_9] == run_servo.value_close_pwm_servo[SERVO_9]){
                    goto BREAK_CLOSE_SERVO_9;
                }
                if(setup_motor.define_speed_servo[SERVO_9] == MAX_PERCENT_SPEED_SERVO){
                    xSemaphoreTake( xMutexI2C, portMAX_DELAY );
                    pwmController.setChannelPWM(SERVO_9, run_servo.value_close_pwm_servo[SERVO_9]);
                    xSemaphoreGive( xMutexI2C );
                    goto DONE_CLOSE_SERVO_NOT_REVERSE_9;
                }
                if(run_servo.value_current_pwm_servo[SERVO_9] <= run_servo.value_close_pwm_servo[SERVO_9]){
                    for(int i = run_servo.value_current_pwm_servo[SERVO_9]; i <= run_servo.value_close_pwm_servo[SERVO_9]; i=i+5){
                        xSemaphoreTake( xMutexI2C, portMAX_DELAY );
                        pwmController.setChannelPWM(SERVO_9, i);
                        xSemaphoreGive( xMutexI2C );
                        vTaskDelay(time_delay/portTICK_RATE_MS);
                    }
                }else{
                    for(int i = run_servo.value_current_pwm_servo[SERVO_9]; i >= run_servo.value_close_pwm_servo[SERVO_9]; i=i-5){
                        xSemaphoreTake( xMutexI2C, portMAX_DELAY );
                        pwmController.setChannelPWM(SERVO_9, i);
                        xSemaphoreGive( xMutexI2C );
                        vTaskDelay(time_delay/portTICK_RATE_MS);
                    }
                }
            DONE_CLOSE_SERVO_NOT_REVERSE_9:
                run_servo.value_current_pwm_servo[SERVO_9] = run_servo.value_close_pwm_servo[SERVO_9];
            }
            if(time_run_servo[SERVO_9] > (millis() - start_time)){
                vTaskDelay((time_run_servo[SERVO_9] - (millis() - start_time))/portTICK_RATE_MS);
            }
        BREAK_CLOSE_SERVO_9:
            stop_led(SERVO_9);
            run_servo.statusCurrentServo[SERVO_9] = SERVO_STOP;
        }
        vTaskDelay(100/portTICK_RATE_MS);
    }
}
